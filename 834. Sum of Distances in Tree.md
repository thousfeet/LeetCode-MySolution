## [834. Sum of Distances in Tree](https://leetcode.com/contest/weekly-contest-84/problems/sum-of-distances-in-tree/)

【题意】

计算一棵树中每个结点到其他所有结点的距离总和。



**Example 1:**

```
Input: N = 6, edges = [[0,1],[0,2],[2,3],[2,4],[2,5]]
Output: [8,12,6,10,10,10]
Explanation: 
Here is a diagram of the given tree:
  0
 / \
1   2
   /|\
  3 4 5
We can see that dist(0,1) + dist(0,2) + dist(0,3) + dist(0,4) + dist(0,5)
equals 1 + 1 + 2 + 2 + 2 = 8.  Hence, answer[0] = 8, and so on.
```

Note: `1 <= N <= 10000`



【思路】

首先把 0 结点的值算出来，显然F(0) = ∑每一层的结点数*层数。

然后来求某个子节点的值。对于任一节点，可以视作以下形态（子节点连着它的所有子树节点（记做N1）和它的父节点，父节点连着这个子节点和其他所有相连的节点（记做N2）），于是整个树结构被划分为4块：子、父、N1、N2。



![picture834](https://raw.githubusercontent.com/thousfeet/LeetCode-MySolution/master/picture834.png)



记 M(node，N) 为node节点到N这个节点集合的distence和的值，有：

F(子) = 子到N1 + 子到父 + 子到N2  -> `F(son) = M(son, N1) + 1 + M(son, N2)`

F(父) = 父到N1 + 父到子 + 父到N2  -> `F(father) = M(father, N1) + 1 + M(father, N2)`

两式相减：

 

> F(son)-F(father) 

>  = M(son, N1) - M(father, N1) + M(son, N2) - M(father, N2)

>  = -N1 + N2

>  = N - 2*N1 - 2（N = N1 + N2 + 2）

最终得到 `F(son) = F(father) + N - 2*N1-2`

因此只要先维护每个子树的节点总数，然后从上往下做就好了。



