## 746. Min Cost Climbing Stairs


>  On a staircase, the i-th step has some non-negative cost cost[i] assigned (0 indexed). Once you pay the cost, you can either climb one or two steps. You need to find minimum cost to reach the top of the floor, and you can either start from the step with index 0, or the step with index 1.
>
>  **Example 1:** 
>  Input: cost = [10, 15, 20] 
>  Output: 15 
>  Explanation: Cheapest is start on cost[1], pay that cost and go to the top.
>
>  **Example 2:** 
>  Input: cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1] 
>  Output: 6 
>  Explanation: Cheapest is start on cost[0], and only step on 1s, skipping cost[3].
>
>  Note:
>
>     cost will have a length in the range [2, 1000].
>     Every cost[i] will be an integer in the range [0, 999].

【思路】
本来在那边兴致勃勃的瞎贪心，贪第一个样例就显然不对了..于是乖乖的开始动规...

偷偷百度了一下小学奥数题走楼梯怎么写的，噢原来就是那个传说中的经典题解，当前方案等于前一节楼梯+前两节楼梯的方案和。搜嘎那我就会了..（一拳就是一个...x）大致思路就是，当到达第 i 节楼梯的总cost值，要不然就是 i-1 那节的总数值加上第 i 节的cost，要不然就是 i-2 那节的总数值加上第 i 节的cost，取一个最小的就好了。（从结果是怎么来的往前想，而不是从第一步往后想这种，也不失为一个好办法）

中间那段代码因为早上被边界坑惨了于是特判了一下边界防RE，如果当前step超过cost数组长度，手动给这个cost值赋值0。

然后写递归写超时了...于是还是老办法，拿了个dp数组来存之前算过的值（以 i 节楼梯为终点的cost），之后就可以直接判断如果dp不为0，算过了的就不用再递归。

LeetCode用全局变量数组会出事，没有手动初始化不会给默认0，所以要手动memset。

【代码】
```
int dp[1010];

int sum(int step,int* cost, int costSize)
{
	if(step == 0) return dp[step] = cost[0];
	if(step == 1) return dp[step] = cost[1];
	
	int c;
	if(step >= costSize) c = 0;
	else c = cost[step];
	
	
	int a = dp[step-1] == 0 ? sum(step-1,cost,costSize) + c : dp[step-1] + c;
	int b = dp[step-2] == 0 ? sum(step-2,cost,costSize) + c : dp[step-2] + c;
	if(a < b) return dp[step] = a;
	return dp[step] = b;
}

int minCostClimbingStairs(int* cost, int costSize) {
	memset(dp,0,sizeof(dp));
	return sum(costSize+1,cost,costSize);
}
```